/*
Copyright 2018 Gravitational, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"bufio"
	"bytes"
	"crypto/tls"
	"flag"
	"fmt"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/gravitational/trace"
	"k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
)

func main() {
	fmt.Println("Attempting to locate and load kubeconfig file")

	var kubeconfig *string
	if home := homeDir(); home != "" {
		kubeconfig = flag.String("kubeconfig", filepath.Join(home, ".kube", "config"), "(optional) absolute path to the kubeconfig file")
	} else {
		kubeconfig = flag.String("kubeconfig", "", "absolute path to the kubeconfig file")
	}
	flag.Parse()

	// use the current context in kubeconfig
	fmt.Println("Loading:", *kubeconfig)
	config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
	if err != nil {
		panic(err.Error())
	}

	err = testUnauthenticated(config)
	if err != nil {
		fmt.Println(trace.DebugReport(err))
	}

	err = testEscalate(config)
	if err != nil {
		fmt.Println(trace.DebugReport(err))
	}
}

// testUnauthenticated does a simple HTTP request to the kubernetes API, to list the available API endpoints
// this should be able to detect most clusters that allow unauthenticated access
func testUnauthenticated(config *rest.Config) error {
	fmt.Println("Testing for unauthenticated access...")

	path := fmt.Sprint(config.Host, "/apis")
	if config.APIPath != "" {
		path = fmt.Sprint(config.Host, config.APIPath, "/apis")
	}
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := http.Client{
		Timeout:   5 * time.Second,
		Transport: tr,
	}
	resp, err := client.Get(path)
	if err != nil {
		return trace.Wrap(err)
	}
	if resp.StatusCode == 200 {
		fmt.Println("> API allows unauthenticated access")
	}
	return nil
}

// testEscalate will try and find a pod running on the cluster, and ty to exec to the pod with an invalid websocket
// request. It will then test if the connection is still available after the invalid connection.
func testEscalate(config *rest.Config) error {
	fmt.Println("Testing for privilege escalation...")
	// Find a random pod on the cluster to run tests against
	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		panic(err.Error())
	}

	pod := findPod(clientset)

	// Build a TLS connection to the kube apiserver to test
	cfg, err := rest.TLSConfigFor(config)
	if err != nil {
		return trace.Wrap(err)
	}

	u, err := url.Parse(config.Host)
	if err != nil {
		return trace.Wrap(err)
	}

	host := u.Host
	if !strings.Contains(host, ":") {
		host = fmt.Sprint(host, ":443")
	}

	conn, err := tls.Dial("tcp", host, cfg)
	if err != nil {
		return trace.Wrap(err)
	}
	defer conn.Close()

	// Build an invalid request, trying to hit the exec URI, but including invalid websocket upgrade requests
	request, err := http.NewRequest("GET", fmt.Sprintf("https://%v/api/v1/namespaces/%v/pods/%v/exec", u.Host, pod.Namespace, pod.Name), nil)
	if err != nil {
		return trace.Wrap(err)
	}
	request.Header.Add("Connection", "upgrade")
	request.Header.Add("Upgrade", "websocket")
	err = request.Write(conn)
	if err != nil {
		return trace.Wrap(err)
	}

	resp, err := http.ReadResponse(bufio.NewReader(conn), nil)
	if err != nil {
		return trace.Wrap(err)
	}
	// read and discard the response body
	var body bytes.Buffer
	body.ReadFrom(resp.Body)

	// See if the socket is still available to write to by sending the request again
	err = trace.ConvertSystemError(request.Write(conn))
	if err != nil && trace.IsEOF(err) {
		// We expected the server to close the connection
		// so this is a good result
		return nil
	}
	if err != nil {
		return trace.Wrap(err)
	}

	resp, err = http.ReadResponse(bufio.NewReader(conn), nil)
	if err != nil && strings.Contains(err.Error(), "unexpected EOF") {
		// We expected the server to close the connection
		// so this is a good result
		return nil
	}
	if err != nil {
		return trace.Wrap(err)
	}
	// read and discard the response body
	body = bytes.Buffer{}
	body.ReadFrom(resp.Body)

	fmt.Println("> API is vulnerable to CVE-2018-1002105")

	return nil
}

func findPod(client *kubernetes.Clientset) v1.Pod {
	namespaces, err := client.CoreV1().Namespaces().List(metav1.ListOptions{})
	if err != nil {
		panic(err.Error())
	}

	for _, namespace := range namespaces.Items {
		pods, err := client.CoreV1().Pods(namespace.Name).List(metav1.ListOptions{})
		if err != nil {
			panic(err.Error())
		}

		if len(pods.Items) > 0 {
			return pods.Items[0]
		}
	}
	panic("Unable to find any pods in cluster")
}

func homeDir() string {
	if h := os.Getenv("HOME"); h != "" {
		return h
	}
	return os.Getenv("USERPROFILE") // windows
}
